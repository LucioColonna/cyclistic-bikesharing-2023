---
title: "Cyclistic 2023 | Data Preparation"
author: "Lucio Colonna"
date: "`r paste('<br>Last updated: ',format(Sys.Date(), '%A %B %d, %Y'),'')`"
output: 
  github_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r global options, include=FALSE}
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)
```

```{r libraries import, include=FALSE}
# import libraries
packages <- c(
  "formatR",
  "tidyverse"
  )


for (pkg in packages) {
  suppressPackageStartupMessages(library(pkg, character.only = TRUE))
}
```

<br>

## Summary {#summary}

<br>

[üìå <strong>Data Source</strong>]{style="color: #0047AB;"}

-   The dataset is segmented into [12 .csv files](#dataframes-import),
    with each file corresponding to a specific month in the year 2023
-   The [consistency](#check-consistency-of-dfs) of the dataframes was
    verified, and they were [merged](#dataframes-merge) into a single
    dataset for further processing

------------------------------------------------------------------------

[üìå <strong>Data Privacy</strong>]{style="color: #0047AB;"}

-   The dataset is **anonymized**, meaning it does not contain any
    personally identifiable information
-   The only identifier is the **ride ID**, which uniquely identifies
    each ride

------------------------------------------------------------------------

[üìå <strong>Data Limitations</strong>]{style="color: #0047AB;"}

-   The anonymization of the dataset prevents linking pass purchases to
    credit card numbers, making it **impossible to determine** if riders
    live in the Chicago area or if they have purchased multiple rides
-   Besides the anonymization point above, the dataset does not provide
    information on the **actual distance travelled** in kilometers. It
    only includes the starting point and ending point, which may lead to
    **approximations** in calculating the distance travelled and the
    speed

<br>

## Dataframes Import {#dataframes-import}

<br>

[‚¨ÖÔ∏è **Back to Summary**](#summary)

<br>

Let's start by importing the dataframes:

```{r import dataframes}
jan23 <- read.csv("Source/202301-divvy-tripdata.csv")
feb23 <- read.csv("Source/202302-divvy-tripdata.csv")
mar23 <- read.csv("Source/202303-divvy-tripdata.csv")
apr23 <- read.csv("Source/202304-divvy-tripdata.csv")
may23 <- read.csv("Source/202305-divvy-tripdata.csv")
jun23 <- read.csv("Source/202306-divvy-tripdata.csv")
jul23 <- read.csv("Source/202307-divvy-tripdata.csv")
aug23 <- read.csv("Source/202308-divvy-tripdata.csv")
sep23 <- read.csv("Source/202309-divvy-tripdata.csv")
oct23 <- read.csv("Source/202310-divvy-tripdata.csv")
nov23 <- read.csv("Source/202311-divvy-tripdata.csv")
dec23 <- read.csv("Source/202312-divvy-tripdata.csv")
```

------------------------------------------------------------------------

Let's analyze the strucure of the first df `jan23`:

```{r examine structure of first dataframe}
str(jan23)
```

<br>

## Check consistency of DFs {#check-consistency-of-dfs}

<br>

[‚¨ÖÔ∏è **Back to Summary**](#summary)

<br>

Our primary task is to merge all datasets into a single dataframe for
further analysis.

However, before proceeding, it's crucial to **ensure uniformity** across
all datasets. This means verifying that each dataset has: 1. the same
**number of columns** 2. identical **column names** 3. identical **data
types**

------------------------------------------------------------------------

What I want to achieve is a comprehensive comparison between **all pairs
of dataframes**. To do that, I have created a function called
`compare_dataframes` that takes a vector of dataframe names as an
argument. - I'm creating a vector `df_names` containing the names of the
12 dataframes, each corresponding to a month. Then, I'm using `get()` to
fetch these dataframes in combination with `lapply()` and store them in
a list called `df_list`

-   Next, I initialize an empty list called `results` to store the
    comparison results

-   I'm running nested loops to compare each dataframe with every other
    dataframe

-   Within these loops, I'm evaluating three conditions: if they have
    the same number of columns (`same_ncol`), if all columns have the
    same data type (`same_class`), and if they have the same column
    names (`same_names`)

-   For each comparison, I'm creating a 1x4 tibble containing the names
    of the dataframes being compared (`comparison`), along with the
    results of the three conditions. This tibble is then appended to the
    `results` list

-   After all comparisons are done, I'm using `bind_rows()` to merge all
    the tibbles into a new tibble named `comparison_results`

-   Finally, I'm returning out the `comparison_results` tibble

```{r}
compare_dataframes <- function(df_names) {

  # get DF names
  df_list <- lapply(df_names, get)

  # initialize empty list
  results <- list()

  # Selection of DF pairs to be compared
  for(i in 1:(length(df_list) - 1)) {
    for(j in (i + 1):length(df_list)) {

      # check column numbers
      same_ncol <- suppressWarnings(ncol(df_list[[i]]) == ncol(df_list[[j]]))

      # check data types
      same_class <- suppressWarnings(all(sapply(df_list[[i]], class) == sapply(df_list[[j]], class)))

      # check column names
      same_names <- suppressWarnings(all(names(df_list[[i]]) == names(df_list[[j]])))

      # append 1x4 tibbles to results list
      results[[length(results) + 1]] <- tibble(
        comparison = paste(df_names[i], "vs", df_names[j]),
        same_ncol = same_ncol,
        same_class = same_class,
        same_names = same_names
      )
    }
  }
  # merge tibbles
  comparison_result <- bind_rows(results)
  return(comparison_result)
}

df_names <- c("jan23", "feb23", "mar23", "apr23", "may23", "jun23", "jul23", "aug23", "sep23", "oct23", "nov23", "dec23")

comparison_result <- compare_dataframes(df_names)

print(comparison_result, n = Inf)
```

------------------------------------------------------------------------

```{r comparison result check}
all(comparison_result$same_ncol & comparison_result$same_class & comparison_result$same_names)
```

All comparisons turned out to be `TRUE`! It means that all datframes
match, so we are clear to proceed with the merging.

<br>

## Dataframes Merge {#dataframes-merge}

<br>

[‚¨ÖÔ∏è **Back to Summary**](#summary)

<br>

Now we can merge all the dataframes using the `rbind()` function:

```{r merge dfs}
trips_2023_merged <- rbind(jan23, feb23, mar23, apr23, may23, jun23, jul23, aug23, sep23, oct23, nov23, dec23)

glimpse(trips_2023_merged)
```

------------------------------------------------------------------------

To improve readibility, I will assign `trips_ 2023_merged` to a new
variable named `df`.

Additionally, to streamline memory usage, I will remove
`trips_2023_merged` and the individual monthly dataframes (`jan23`,
`feb23`, ..., `dec23`).

```{r reassign variable and remove useless objects}
df <- trips_2023_merged

rm(trips_2023_merged, jan23, feb23, mar23, apr23, may23, jun23, jul23, aug23, sep23, oct23, nov23, dec23)
```

```{r write .csv file to be used for the processing phase, include=FALSE}
# write .csv file to be used for processing phase
write.csv(df, "Source/df.csv", row.names = FALSE)
```
